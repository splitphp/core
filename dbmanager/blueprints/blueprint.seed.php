<?php
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                                                                //
//                                                                ** SPLIT PHP FRAMEWORK **                                                                       //
// This file is part of *SPLIT PHP Framework*                                                                                                                     //
//                                                                                                                                                                //
// Why "SPLIT"? Firstly because the word "split" is a reference to micro-services and split systems architecture (of course you can make monoliths with it,       //
// if that's your thing). Furthermore, it is an acronym for these 5 bound concepts which are the bases that this framework leans on, which are: "Simplicity",     //
// "Purity", "Lightness", "Intuitiveness", "Target Minded"                                                                                                        //
//                                                                                                                                                                //
// See more info about it at: https://github.com/gabriel-guelfi/split-php                                                                                         //
//                                                                                                                                                                //
// MIT License                                                                                                                                                    //
//                                                                                                                                                                //
// Copyright (c) 2025 Lightertools Open Source Community                                                                                                          //
//                                                                                                                                                                //
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to          //
// deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or         //
// sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:                            //
//                                                                                                                                                                //
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.                                 //
//                                                                                                                                                                //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS     //
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY           //
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.     //
//                                                                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace SplitPHP\DbManager;

use SplitPHP\Helpers;
use SplitPHP\Database\DbVocab;
use SplitPHP\Database\Database;
use SplitPHP\Database\Sql;
use SplitPHP\Database\Sqlobj;
use SplitPHP\ObjLoader;
use Exception;

/**
 * Seed class for generating seed data for database tables.
 *
 * This class allows you to define seed data for a table, including setting fixed values,
 * random values, and values generated by functions. It supports various data types and
 * constraints such as nullable fields and auto-incrementing fields.
 */
final class SeedBlueprint
{
  /**
   * @var string The name of the seed blueprint.
   */
  private string $name;

  /**
   * @var string The name of the table for which seed data is being generated.
   */
  private string $tableName;

  /**
   * @var array The seed data for the table.
   */
  private array $data;

  /**
   * @var int The batch size for inserting seed data.
   */
  private int $batchSize;

  /**
   * @var object|null The currently edited field for setting values.
   */
  private ?object $editingField;

  /**
   * @var Sql The SQL builder instance for generating SQL statements.
   */
  private Sql $sqlBuilder;

  /**
   * @var array The indexes for the table.
   */
  private array $indexes;

  /**
   * @var array The INSERT dataset for the table.
   */
  private array $dataset;

  /**
   * @var array The environments in which this seed should run.
   */
  private array $allowedEnvs;

  /**
   * Constructor for the Seed class.
   *
   * @param string $tableName The name of the table for which seed data is being generated.
   * @param int $batchSize The batch size for inserting seed data. Default is 1.
   */
  public function __construct(string $tableName, int $batchSize = 1)
  {
    $this->name = $tableName . '_seed';
    $this->tableName = $tableName;
    $this->data = [];
    $this->indexes = [];
    $this->dataset = [];
    $this->allowedEnvs = [];
    $this->batchSize = $batchSize;
    $this->editingField = null;
    $this->sqlBuilder = ObjLoader::load(CORE_PATH . '/database/' . Database::getRdbmsName() . '/class.sql.php');

    $tbBlueprint = Helpers::DbMapper()->tableBlueprint($tableName);

    foreach ($tbBlueprint->getColumns() as $column) {
      $this->data[$column->getName()] = (object)[
        'name' => $column->getName(),
        'locked' => $column->hasAutoIncrement(),
        'nullable' => $column->isNullable(),
        'maxlength' => $column->getLength(),
        'type' => $column->getType(),
        'isIndex' => false,
        'value' => null,
        'fn' => null,
      ];

      if (!$column->hasDefaultValue() && !$this->data[$column->getName()]->locked) {
        $this->data[$column->getName()]->value = null;

        switch ($column->getType()) {
          case 'string':
          case 'text':
            $this->onField($column->getName())->setRandomStr();
            break;
          case 'int':
            $this->onField($column->getName())->setRandomInt();
            break;
          case 'float':
            $this->onField($column->getName())->setRandomFloat();
            break;
          case 'date':
          case 'datetime':
          case 'timestamp':
            $this->onField($column->getName())->setRandomDateTime();
            break;
        }
      }
    }
  }

  /**
   * Get the name of the seed blueprint.
   *
   * @return string The name of the seed blueprint.
   */
  public function getName(): string
  {
    return $this->name;
  }

  /**
   * Get the batch size for inserting seed data.
   *
   * @return int The batch size.
   */
  public function getBatchSize(): int
  {
    return $this->batchSize;
  }

  /**
   * Specify the field to edit.
   *
   * @param string $field The name of the field to edit.
   * @return self
   */
  public function onField(string $field, bool $tagAsIndex = false): self
  {
    if (!isset($this->data[$field])) {
      throw new \Exception("Field '{$field}' does not exist in the seed data for table '{$this->tableName}'.");
    }

    if ($this->data[$field]->locked) {
      throw new \Exception("Field '{$field}' is locked, its value is auto-generated by the database and cannot be edited in the seed data for table '{$this->tableName}'.");
    }

    $this->editingField = $this->data[$field] ?? null;

    if ($tagAsIndex && $this->editingField) {
      $this->editingField->isIndex = true;
      $this->indexes[] = $this->editingField->name; // Add to indexes if tagged
    }

    return $this;
  }

  /**
   * Set a fixed value for the currently edited field.
   *
   * @param mixed $value The fixed value to set.
   * @return self
   */
  public function setFixedValue(mixed $value): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setFixedValue().");
    }

    if (is_string($value) && $this->editingField->maxlength && mb_strlen($value) > $this->editingField->maxlength) {
      throw new \Exception("Value for field '{$this->editingField->name}' exceeds maximum length of {$this->editingField->maxlength} characters.");
    }

    if (is_null($value) && !$this->editingField->nullable) {
      throw new \Exception("Field '{$this->editingField->name}' cannot be set to null as it is not nullable in the seed data for table '{$this->tableName}'.");
    }

    $this->editingField->value = $value;
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value
    return $this;
  }

  /**
   * Set a random string value for the currently edited field.
   *
   * @param int $minlength The minimum length of the random string.
   * @param int $maxlength The maximum length of the random string.
   * @return self
   */
  public function setRandomStr($minlength = 0, $maxlength = 255): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling randomStr().");
    }

    if ($this->editingField->type != 'string' && $this->editingField->type != 'text') {
      throw new \Exception("Field '{$this->editingField->name}' is not of type 'string' or 'text', cannot set random string value.");
    }

    if ($this->editingField->maxlength && $maxlength > $this->editingField->maxlength) {
      $maxlength = $this->editingField->maxlength;
    }

    if ($minlength < 0) {
      $minlength = 0;
    }

    if ($maxlength < 1) {
      $maxlength = 1;
    }

    if ($maxlength < $minlength) {
      throw new \Exception("Maximum length cannot be less than minimum length.");
    }

    $length = rand($minlength, $maxlength);
    $this->editingField->fn = function () use ($length) {
      return substr(str_shuffle(str_repeat("0123456789abcdefghijklmnopqrstuvwxyz", ceil($length / 36))), 1, $length);
    };

    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a random integer value for the currently edited field.
   *
   * @param int $min The minimum value of the random integer.
   * @param int $max The maximum value of the random integer.
   * @return self
   */
  public function setRandomInt($min = 0, $max = PHP_INT_MAX): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setRandomInt().");
    }

    if ($this->editingField->type != 'int') {
      throw new \Exception("Field '{$this->editingField->name}' is not of type 'int', cannot set random integer value.");
    }

    if ($min < 0) {
      $min = 0;
    }

    if ($max < 1) {
      $max = 1;
    }

    if ($max < $min) {
      throw new \Exception("Maximum value cannot be less than minimum value.");
    }

    $this->editingField->fn = function () use ($min, $max) {
      return rand($min, $max);
    };
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a random float value for the currently edited field.
   *
   * @param float $min The minimum value of the random float.
   * @param float $max The maximum value of the random float.
   * @return self
   */
  public function setRandomFloat($min = 0, $max = PHP_FLOAT_MAX): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setRandomFloat().");
    }

    if ($this->editingField->type != 'float') {
      throw new \Exception("Field '{$this->editingField->name}' is not of type 'float', cannot set random float value.");
    }

    if ($min < 0) {
      $min = 0;
    }

    if ($max < 1) {
      $max = 1;
    }

    if ($max < $min) {
      throw new \Exception("Maximum value cannot be less than minimum value.");
    }

    $this->editingField->fn = function () use ($min, $max) {
      return mt_rand($min * 100, $max * 100) / 100;
    };
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a random date value for the currently edited field.
   *
   * @param string $start The start date (inclusive).
   * @param string $end The end date (inclusive).
   * @return self
   */
  public function setRandomDate($start = '2000-01-01', $end = '2100-12-31'): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setRandomDate().");
    }

    if (!in_array($this->editingField->type, DbVocab::DATATYPE_GROUPS['dateAndTime'])) {
      throw new \Exception("Field '{$this->editingField->name}' is not of type date, cannot set random date value.");
    }

    $startTimestamp = strtotime($start);
    $endTimestamp = strtotime($end);

    if ($endTimestamp < $startTimestamp) {
      throw new \Exception("End date cannot be earlier than start date.");
    }

    $this->editingField->fn = function () use ($startTimestamp, $endTimestamp) {
      $randomTimestamp = rand($startTimestamp, $endTimestamp);
      return date('Y-m-d', $randomTimestamp);
    };
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a random date and time value for the currently edited field.
   *
   * @param string $start The start date and time (inclusive).
   * @param string $end The end date and time (inclusive).
   * @return self
   */
  public function setRandomDateTime($start = '2000-01-01 00:00:00', $end = '2100-12-31 23:59:59'): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setRandomDateTime().");
    }

    if (!in_array($this->editingField->type, DbVocab::DATATYPE_GROUPS['dateAndTime'])) {
      throw new \Exception("Field '{$this->editingField->name}' is not of type date or time, cannot set random datetime value.");
    }

    $startTimestamp = strtotime($start);
    $endTimestamp = strtotime($end);

    if ($endTimestamp < $startTimestamp) {
      throw new \Exception("End date cannot be earlier than start date.");
    }

    $this->editingField->fn = function () use ($startTimestamp, $endTimestamp) {
      $randomTimestamp = rand($startTimestamp, $endTimestamp);
      return date('Y-m-d H:i:s', $randomTimestamp);
    };
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a random enum value for the currently edited field.
   *
   * @param array $values The array of possible enum values.
   * @return self
   */
  public function setRandomEnum(array $values): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setRandomEnum().");
    }

    if ($this->editingField->type != 'string' && $this->editingField->type != 'text' && $this->editingField->type != 'int' && $this->editingField->type != 'float') {
      throw new \Exception("Field '{$this->editingField->name}' has not a type that can holdenum value.");
    }

    if (empty($values)) {
      throw new \Exception("Enum values array cannot be empty.");
    }

    $this->editingField->fn = function () use ($values) {
      return $values[array_rand($values)];
    };
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a value for the currently edited field using a callback function.
   *
   * @param callable $function The callback function to generate the value.
   * @return self
   */
  public function setByFunction(callable $function): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setByFunction().");
    }

    $resultValue = $function();

    if (gettype($resultValue) !== $this->editingField->type) {
      throw new \Exception("Function result type does not match field type '{$this->editingField->type}' for field '{$this->editingField->name}'.");
    }

    $this->editingField->fn = $function;
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Specify the environments in which this seed should run.
   *
   * @param array $envs An array of environment names (strings).
   * @return self
   * @throws \Exception If any environment name is not a string.
   */
  public function onlyRunInEnvs(array $envs): self
  {
    foreach ($envs as $env) {
      if (!is_string($env)) {
        throw new \Exception("Each environment in the allowed environments array must be a string.");
      }
    }

    $this->allowedEnvs = $envs;
    return $this;
  }

  /**
   * Check if the seed is allowed to run in the specified environment.
   *
   * @param string $env The environment name to check.
   * @return bool True if the seed is allowed in the specified environment, false otherwise.
   */
  public function isAllowedInEnv(string $env): bool
  {
    if (empty($this->allowedEnvs)) {
      return true; // If no environments are specified, allow all
    }

    return in_array($env, $this->allowedEnvs);
  }

  /**
   * Get the seed data for the table.
   *
   * @return array The seed data.
   */
  public function getData(): array
  {
    return $this->data;
  }

  /**
   * Obtain the SQL statements for applying and reverting the seed data.
   *
   * @return object An object containing 'up' and 'down' SQL statements.
   */
  public function obtainSql(): object
  {
    return (object)[
      'up' => $this->obtainUpSql(),
      'down' => $this->obtainDownSql(),
    ];
  }

  /**
   * Generate the SQL statement for inserting the seed data into the table.
   *
   * @return Sqlobj The SQL object containing the insert statement.
   */
  private function obtainUpSql(): Sqlobj
  {
    $dataset = [];
    for ($i = 0; $i < $this->batchSize; $i++) {
      $row = [];
      foreach ($this->data as $field) {
        if ($field->value !== null) {
          $row[$field->name] = $field->value;
        } elseif ($field->fn !== null && is_callable($field->fn)) {
          $row[$field->name] = ($field->fn)();
        }
      }
      $dataset[] = $row;
    }

    $this->dataset = $dataset;

    return $this->sqlBuilder
      ->insert($dataset, $this->tableName)
      ->output(true);
  }

  /**
   * Generate the SQL statement for reverting the seed data from the table.
   *
   * @return Sqlobj The SQL object containing the delete statement.
   */
  private function obtainDownSql(): Sqlobj
  {
    $filters = [];

    foreach ($this->dataset as $row) {
      foreach ($this->indexes as $fieldName) {
        if (!array_key_exists($fieldName, $filters))
          $filters[$fieldName] = (object) [
            'key' => $fieldName,
            'value' => [],
            'joint' => 'AND',
            'operator' => 'IN',
            'sanitize' => true,
          ];

        $filters[$fieldName]->value[] = $row[$fieldName];
      }
    }

    if (empty($filters)) {
      throw new Exception("Cannot generate seed reversion: no fields with value tagged as index in the seed dataset for table '{$this->tableName}'.");
    }

    return $this->sqlBuilder
      ->delete($this->tableName)
      ->where(array_values($filters))
      ->output(true);
  }
}
