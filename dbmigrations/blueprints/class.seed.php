<?php

namespace SplitPHP\DbMigrations;

use SplitPHP\Database\DbVocab;

/**
 * Seed class for generating seed data for database tables.
 *
 * This class allows you to define seed data for a table, including setting fixed values,
 * random values, and values generated by functions. It supports various data types and
 * constraints such as nullable fields and auto-incrementing fields.
 */
final class Seed extends Blueprint
{
  /**
   * @var array The seed data for the table.
   */
  private array $data;

  /**
   * @var int The batch size for inserting seed data.
   */
  private int $batchSize;

  /**
   * @var object|null The currently edited field for setting values.
   */
  private ?object $editingField;

  /**
   * Constructor for the Seed class.
   *
   * @param TableBlueprint $tableBlueprint The blueprint of the table for which seed data is being generated.
   * @param int $batchSize The batch size for inserting seed data. Default is 1.
   */
  public function __construct(TableBlueprint $tableRef, int $batchSize = 1)
  {
    $this->name = $tableRef->getName() . '_seed';
    $this->tableRef = $tableRef;
    $this->data = [];
    $this->batchSize = $batchSize;
    $this->editingField = null;

    foreach ($tableRef->getColumns() as $column) {
      $this->data[$column->getName()] = (object)[
        'name' => $column->getName(),
        'locked' => $column->hasAutoIncrement(),
        'nullable' => $column->isNullable(),
        'maxlength' => $column->getLength(),
        'type' => $column->getType(),
      ];

      if ($column->hasDefaultValue()) {
        $this->data[$column->getName()]->value = $column->getDefaultValue();
        $this->data[$column->getName()]->fn = null;
      } else {
        $this->data[$column->getName()]->value = null;

        switch ($column->getType()) {
          case 'string':
          case 'text':
            $this->onField($column->getName())->setRandomStr();
            break;
          case 'int':
            $this->onField($column->getName())->setRandomInt();
            break;
          case 'float':
            $this->onField($column->getName())->setRandomFloat();
            break;
          case 'date':
          case 'datetime':
          case 'timestamp':
            $this->onField($column->getName())->setRandomDateTime();
            break;
        }
      }
    }
  }

  /**
   * Get the batch size for inserting seed data.
   *
   * @return int The batch size.
   */
  public function getBatchSize(): int
  {
    return $this->batchSize;
  }

  /**
   * Specify the field to edit.
   *
   * @param string $field The name of the field to edit.
   * @return self
   */
  public function onField(string $field): self
  {
    if (!isset($this->data[$field])) {
      throw new \Exception("Field '{$field}' does not exist in the seed data for table '{$this->tableRef->getName()}'.");
    }

    if ($this->data[$field]->locked) {
      throw new \Exception("Field '{$field}' is locked, its value is auto-generated by the database and cannot be edited in the seed data for table '{$this->tableRef->getName()}'.");
    }

    $this->editingField = $this->data[$field] ?? null;

    return $this;
  }

  /**
   * Set a fixed value for the currently edited field.
   *
   * @param mixed $value The fixed value to set.
   * @return self
   */
  public function setFixedValue(mixed $value): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setFixedValue().");
    }

    if (is_string($value) && $this->editingField->maxlength && mb_strlen($value) > $this->editingField->maxlength) {
      throw new \Exception("Value for field '{$this->editingField->name}' exceeds maximum length of {$this->editingField->maxlength} characters.");
    }

    if (is_null($value) && !$this->editingField->nullable) {
      throw new \Exception("Field '{$this->editingField->name}' cannot be set to null as it is not nullable in the seed data for table '{$this->tableRef->getName()}'.");
    }

    $this->editingField->value = $value;
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value
    return $this;
  }

  /**
   * Set a random string value for the currently edited field.
   *
   * @param int $minlength The minimum length of the random string.
   * @param int $maxlength The maximum length of the random string.
   * @return self
   */
  public function setRandomStr($minlength = 0, $maxlength = 255): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling randomStr().");
    }

    if ($this->editingField->type != 'string' && $this->editingField->type != 'text') {
      throw new \Exception("Field '{$this->editingField->name}' is not of type 'string' or 'text', cannot set random string value.");
    }

    if ($this->editingField->maxlength && $maxlength > $this->editingField->maxlength) {
      $maxlength = $this->editingField->maxlength;
    }

    if ($minlength < 0) {
      $minlength = 0;
    }

    if ($maxlength < 1) {
      $maxlength = 1;
    }

    if ($maxlength < $minlength) {
      throw new \Exception("Maximum length cannot be less than minimum length.");
    }

    $length = rand($minlength, $maxlength);
    $this->editingField->fn = function () use ($length) {
      return substr(str_shuffle(str_repeat("0123456789abcdefghijklmnopqrstuvwxyz", ceil($length / 36))), 1, $length);
    };

    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a random integer value for the currently edited field.
   *
   * @param int $min The minimum value of the random integer.
   * @param int $max The maximum value of the random integer.
   * @return self
   */
  public function setRandomInt($min = 0, $max = PHP_INT_MAX): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setRandomInt().");
    }

    if ($this->editingField->type != 'int') {
      throw new \Exception("Field '{$this->editingField->name}' is not of type 'int', cannot set random integer value.");
    }

    if ($min < 0) {
      $min = 0;
    }

    if ($max < 1) {
      $max = 1;
    }

    if ($max < $min) {
      throw new \Exception("Maximum value cannot be less than minimum value.");
    }

    $this->editingField->fn = function () use ($min, $max) {
      return rand($min, $max);
    };
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a random float value for the currently edited field.
   *
   * @param float $min The minimum value of the random float.
   * @param float $max The maximum value of the random float.
   * @return self
   */
  public function setRandomFloat($min = 0, $max = PHP_FLOAT_MAX): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setRandomFloat().");
    }

    if ($this->editingField->type != 'float') {
      throw new \Exception("Field '{$this->editingField->name}' is not of type 'float', cannot set random float value.");
    }

    if ($min < 0) {
      $min = 0;
    }

    if ($max < 1) {
      $max = 1;
    }

    if ($max < $min) {
      throw new \Exception("Maximum value cannot be less than minimum value.");
    }

    $this->editingField->fn = function () use ($min, $max) {
      return mt_rand($min * 100, $max * 100) / 100;
    };
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a random date and time value for the currently edited field.
   *
   * @param string $start The start date and time (inclusive).
   * @param string $end The end date and time (inclusive).
   * @return self
   */
  public function setRandomDateTime($start = '2000-01-01 00:00:00', $end = '2100-12-31 23:59:59'): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setRandomDateTime().");
    }

    if (!in_array($this->editingField->type, DbVocab::DATATYPE_GROUPS['dateAndTime'])) {
      throw new \Exception("Field '{$this->editingField->name}' is not of type date or time, cannot set random datetime value.");
    }

    $startTimestamp = strtotime($start);
    $endTimestamp = strtotime($end);

    if ($endTimestamp < $startTimestamp) {
      throw new \Exception("End date cannot be earlier than start date.");
    }

    $this->editingField->fn = function () use ($startTimestamp, $endTimestamp) {
      $randomTimestamp = rand($startTimestamp, $endTimestamp);
      return date('Y-m-d H:i:s', $randomTimestamp);
    };
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a random enum value for the currently edited field.
   *
   * @param array $values The array of possible enum values.
   * @return self
   */
  public function setRandomEnum(array $values): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setRandomEnum().");
    }

    if ($this->editingField->type != 'string' && $this->editingField->type != 'text' && $this->editingField->type != 'int' && $this->editingField->type != 'float') {
      throw new \Exception("Field '{$this->editingField->name}' has not a type that can holdenum value.");
    }

    if (empty($values)) {
      throw new \Exception("Enum values array cannot be empty.");
    }

    $this->editingField->fn = function () use ($values) {
      return $values[array_rand($values)];
    };
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Set a value for the currently edited field using a callback function.
   *
   * @param callable $function The callback function to generate the value.
   * @return self
   */
  public function setByFunction(callable $function): self
  {
    if (!$this->editingField) {
      throw new \Exception("No field is currently being edited. Use onField() to specify a field before calling setByFunction().");
    }

    $resultValue = $function();

    if (gettype($resultValue) !== $this->editingField->type) {
      throw new \Exception("Function result type does not match field type '{$this->editingField->type}' for field '{$this->editingField->name}'.");
    }

    $this->editingField->fn = $function;
    $this->data[$this->editingField->name] = $this->editingField; // Update the data array
    $this->editingField = null; // Reset editing field after setting value

    return $this;
  }

  /**
   * Get the seed data for the table.
   *
   * @return array The seed data.
   */
  public function getData(): array
  {
    return $this->data;
  }
}
